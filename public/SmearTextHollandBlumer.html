<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Springy Blob Text - Holland Blumer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #c5c5c5;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script>
      const params = new URLSearchParams(window.location.search);
      const TEXT_STRING = params.get("text") || "HOLLAND BLUMER";

      const DEFAULT_SCALE = 3.7;
      let scaleRaw = parseFloat(params.get("scale"));
      if (Number.isNaN(scaleRaw)) scaleRaw = DEFAULT_SCALE;

      // Expanded range to allow larger letters for long names
      const SCALE_MULTIPLIER = Math.min(Math.max(scaleRaw, 2.0), 8.0);

      let letterFont;
      const FONT_URL =
        "https://assets.codepen.io/9259849/RubikMonoOne-Regular_1.ttf";
      const vertexDistanceRel = 0.008;
      let effectiveVertexDistance;

      /* Physics Classes */
      class Point {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
        moveTo(x, y) {
          this.x = x;
          this.y = y;
          return this;
        }
        delta(p) {
          return [this.x - p.x, this.y - p.y];
        }
        distance(p) {
          return dist(this.x, this.y, p.x, p.y);
        }
      }

      const ELASTICITY = 0.03,
        DAMPING = 0.75,
        MASS = 2,
        ADJACENT_SPRING_CONSTANT = 0.1;
      let MOUSE_STRENGTH = 0.7,
        MOUSE_RADIUS;
      const AUTO_WOBBLE_STRENGTH = 0.4;

      class Spring extends Point {
        constructor({
          x,
          y,
          mass = MASS,
          elasticity = ELASTICITY,
          damping = DAMPING,
        }) {
          super(x, y);
          this.ox = x;
          this.oy = y;
          this.vx = 0;
          this.vy = 0;
          this.fx = 0;
          this.fy = 0;
          this.mass = mass;
          this.elasticity = elasticity;
          this.damping = damping;
          this.attractors = [];
        }
        applyForce(x, y) {
          this.fx += x;
          this.fy += y;
        }
        addAttractor(p) {
          this.attractors.push(p);
        }
        setForceFromAttractors() {
          this.attractors.forEach((p) => {
            this.applyForce(
              ADJACENT_SPRING_CONSTANT * p.vx,
              ADJACENT_SPRING_CONSTANT * p.vy
            );
          });
        }
        applyForceFromMouse(pointer) {
          const distance = this.distance(pointer.position);
          if (distance < MOUSE_RADIUS) {
            const [dx, dy] = pointer.delta();
            const power = (1 - distance / MOUSE_RADIUS) * MOUSE_STRENGTH;
            this.applyForce(dx * power, dy * power);
          }
        }
        applyAutoWobble() {
          const t = frameCount * 0.01;
          const nx = noise(this.ox * 0.01, this.oy * 0.01, t);
          const ny = noise(this.ox * 0.01 + 100, this.oy * 0.01 + 100, t);
          this.applyForce(
            (nx - 0.5) * AUTO_WOBBLE_STRENGTH,
            (ny - 0.5) * AUTO_WOBBLE_STRENGTH
          );
        }
        setSpringForce() {
          this.fx += (this.ox - this.x) * this.elasticity;
          this.fy += (this.oy - this.y) * this.elasticity;
        }
        solveVelocity() {
          this.vx = this.damping * this.vx + this.fx / this.mass;
          this.vy = this.damping * this.vy + this.fy / this.mass;
          this.x += this.vx;
          this.y += this.vy;
          this.fx = 0;
          this.fy = 0;
        }
        update(pointer) {
          this.setForceFromAttractors();
          this.applyForceFromMouse(pointer);
          this.applyAutoWobble();
          this.setSpringForce();
          this.solveVelocity();
        }
      }

      class SpringPointer {
        constructor(x, y) {
          this.position = new Point(x, y);
          this.lastPosition = new Point(x, y);
        }
        updateFromMouse(mx, my) {
          this.lastPosition.moveTo(this.position.x, this.position.y);
          this.position.moveTo(mx, my);
        }
        delta() {
          return this.position.delta(this.lastPosition);
        }
      }

      let pointer,
        springs = [],
        blobs = [],
        designW,
        designH,
        viewScale = 1;

      function preload() {
        letterFont = loadFont(FONT_URL);
      }

      function setup() {
        createCanvas(windowWidth, windowHeight);
        buildLetters();
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        buildLetters();
      }

      function buildLetters() {
        springs = [];
        blobs = [];

        // Base sizing
        const baseRef = min(windowWidth, windowHeight);
        const radius = baseRef * 0.16;
        const fontSize = radius * SCALE_MULTIPLIER;

        // Measure text to define designW dynamically
        const charInfos = TEXT_STRING.split("").map((ch) => {
          if (ch === " ")
            return { char: " ", width: fontSize * 0.3, isSpace: true };
          const b = letterFont.textBounds(ch, 0, 0, fontSize);
          return { char: ch, width: b.w, isSpace: false };
        });

        const LETTER_GAP = fontSize * 0.05;
        let totalTextW = charInfos.reduce(
          (acc, cur, i) =>
            acc + cur.width + (i < charInfos.length - 1 ? LETTER_GAP : 0),
          0
        );

        // Adjust design space to fit the text + padding
        designW = totalTextW + windowWidth * 0.2;
        designH = windowHeight;

        effectiveVertexDistance = vertexDistanceRel * min(designW, designH);
        MOUSE_RADIUS = min(designW, designH) * 0.15;
        pointer = new SpringPointer(designW / 2, designH / 2);

        let xCursor = (designW - totalTextW) / 2;
        const baseY = designH * 0.55;

        charInfos.forEach((info, i) => {
          if (info.isSpace) {
            xCursor += info.width + LETTER_GAP;
            return;
          }
          const cx = xCursor + info.width / 2;
          const blobLoops = generateLetterLoops(
            cx,
            baseY,
            radius,
            info.char,
            fontSize
          );
          blobs.push({ loops: blobLoops });
          blobLoops.forEach((loop) => {
            springs.push(...loop);
            loop.forEach((s, j) => {
              s.addAttractor(loop[(j - 1 + loop.length) % loop.length]);
              s.addAttractor(loop[(j + 1) % loop.length]);
            });
          });
          xCursor += info.width + LETTER_GAP;
        });
      }

      function generateLetterLoops(offsetX, offsetY, radius, letter, fontSize) {
        const bounds = letterFont.textBounds(letter, 0, 0, fontSize);
        const pts = letterFont.textToPoints(letter, 0, 0, fontSize, {
          sampleFactor: 0.5,
        });
        const allLoops = [];
        let currentLoop = [];

        for (let i = 0; i < pts.length; i++) {
          if (
            i > 0 &&
            dist(pts[i].x, pts[i].y, pts[i - 1].x, pts[i - 1].y) > 20
          ) {
            if (currentLoop.length > 2) allLoops.push(currentLoop);
            currentLoop = [];
          }
          currentLoop.push(
            new Spring({
              x: pts[i].x - bounds.x - bounds.w / 2 + offsetX,
              y: pts[i].y - bounds.y - bounds.h / 2 + offsetY,
              elasticity: random(0.02, 0.04),
              damping: random(0.7, 0.8),
            })
          );
        }
        if (currentLoop.length > 2) allLoops.push(currentLoop);
        return allLoops;
      }

      function draw() {
        background("#c5c5c5");
        viewScale = windowWidth / designW; // Force width-based scaling

        const mx = mouseX / viewScale;
        const my = mouseY / viewScale;
        pointer.updateFromMouse(mx, my);

        push();
        scale(viewScale);
        springs.forEach((s) => s.update(pointer));
        blobs.forEach(drawLetterBlob);
        pop();
      }

      function drawLetterBlob(blob) {
        const ctx = drawingContext;
        ctx.save();
        ctx.fillStyle = "#F7EAAC";
        ctx.beginPath();
        blob.loops.forEach((loop) => {
          ctx.moveTo(loop[0].x, loop[0].y);
          for (let i = 1; i < loop.length; i++)
            ctx.lineTo(loop[i].x, loop[i].y);
          ctx.closePath();
        });
        ctx.fill("evenodd");
        ctx.restore();
      }
    </script>
  </body>
</html>
