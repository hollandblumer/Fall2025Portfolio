<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Squishy HOLLAND – readable first, then pack</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>

    <style>
      :root {
        --film-opacity: 0.7;
        --film-blend: soft-light;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #c5c5c5;
      }

      body {
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      canvas {
        display: block;
        touch-action: none;
      }

      #filmLayer {
        position: fixed;
        inset: 0;
        z-index: 0;
        pointer-events: none;
        mix-blend-mode: var(--film-blend);
        opacity: var(--film-opacity);
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="filmLayer"></canvas>

    <script type="module">
      import * as THREE from "https://esm.sh/three";
      import { EffectComposer } from "https://esm.sh/three/examples/jsm/postprocessing/EffectComposer.js";
      import { RenderPass } from "https://esm.sh/three/examples/jsm/postprocessing/RenderPass.js";
      import { FilmPass } from "https://esm.sh/three/examples/jsm/postprocessing/FilmPass.js";
      import { OutputPass } from "https://esm.sh/three/examples/jsm/postprocessing/OutputPass.js";

      const canvas = document.getElementById("filmLayer");

      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: false,
        alpha: true,
      });
      renderer.setClearColor(0x000000, 0);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x808080);
      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

      const composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));

      const filmPass = new FilmPass(0.26, 0.24, 648, false);
      composer.addPass(filmPass);

      composer.addPass(new OutputPass());

      function onResize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
        renderer.setPixelRatio(dpr);
        renderer.setSize(window.innerWidth, window.innerHeight, false);
        composer.setSize(window.innerWidth, window.innerHeight);
      }

      window.addEventListener("resize", onResize);
      onResize();

      (function loop() {
        composer.render();
        requestAnimationFrame(loop);
      })();
    </script>

    <script>
      /* --------------------------------------------------------
          Basic 2D coordinate + geometry utilities
      -------------------------------------------------------- */

      class Coordinate2D {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
      }

      const geometry = {
        limit: (coord, maxLength) => {
          if (!coord) return null;
          let mag = Math.sqrt(coord.x * coord.x + coord.y * coord.y);
          if (mag > maxLength) {
            return {
              x: (coord.x / mag) * maxLength,
              y: (coord.y / mag) * maxLength,
            };
          }
          return coord;
        },

        polygonArea: (polygon) => {
          let area = 0;
          const n = polygon.length;
          for (let i = 1; i <= n; i++) {
            area +=
              polygon[i % n].x *
              (polygon[(i + 1) % n].y - polygon[(i - 1) % n].y);
          }
          return area / 2;
        },
      };

      /* --------------------------------------------------------
          Particles + joints
      -------------------------------------------------------- */

      class Particle extends Coordinate2D {
        constructor({ x, y, radius, damping, friction, mass }) {
          super(x, y);
          this.prevX = x;
          this.prevY = y;
          this.vx = 0;
          this.vy = 0;
          this.radius = radius ?? 10;
          this.baseRadius = this.radius;
          this.damping = damping ?? 0.9;
          this.friction = friction ?? 0.1;
          this.mass = mass ?? 1;

          this.restDX = 0;
          this.restDY = 0;

          this.squishWeight = 1;
          this.anchorWeight = 1;
        }

        setClient(client) {
          this.client = client;
        }

        move(dx, dy) {
          this.x += dx;
          this.y += dy;
        }

        testCollision(otherX, otherY, radius) {
          const diffx = otherX - this.x;
          const diffy = otherY - this.y;
          const diffMag = diffx * diffx + diffy * diffy;
          const combinedRadius = radius + this.radius;
          if (diffMag < combinedRadius * combinedRadius) {
            const dist = Math.sqrt(diffMag);
            const overlap = combinedRadius - dist;
            if (dist === 0) return new Coordinate2D(0, 0);
            const nx = diffx / dist;
            const ny = diffy / dist;
            return new Coordinate2D(-nx * overlap, -ny * overlap);
          }
          return null;
        }

        collide(otherX, otherY, radius) {
          const diffx = otherX - this.x;
          const diffy = otherY - this.y;
          const diffMag = diffx * diffx + diffy * diffy;
          const combinedRadius = radius + this.radius;
          if (diffMag < combinedRadius * combinedRadius) {
            const dist = Math.sqrt(diffMag);
            const overlap = combinedRadius - dist;
            if (dist === 0) return null;
            const nx = diffx / dist;
            const ny = diffy / dist;

            this.move(-nx * overlap * 0.5, -ny * overlap * 0.5);
            this.prevX = lerp(this.prevX, this.x, this.friction);
            this.prevY = lerp(this.prevY, this.y, this.friction);

            return new Coordinate2D(-nx * overlap, -ny * overlap);
          }
          return null;
        }

        constrain(left, top, right, bottom) {
          const { x, y, friction, radius } = this;

          left += radius;
          top += radius;
          right -= radius;
          bottom -= radius;

          let collide = false;

          if (x > right) {
            this.x = right;
            collide = true;
          } else if (x < left) {
            this.x = left;
            collide = true;
          }
          if (y > bottom) {
            this.y = bottom;
            collide = true;
          } else if (y < top) {
            this.y = top;
            collide = true;
          }

          if (collide) {
            this.prevX = lerp(this.prevX, this.x, friction);
            this.prevY = lerp(this.prevY, this.y, friction);
          }
        }

        update(dt = 1) {
          this.prevX = this.x;
          this.prevY = this.y;
          this.x += this.vx * dt;
          this.y += this.vy * dt;
        }

        endUpdate(dt = 1) {
          const m = this.damping / dt;
          this.vx = (this.x - this.prevX) * m;
          this.vy = (this.y - this.prevY) * m;
        }

        updateClient() {
          if (this.client) this.client.update();
        }
      }

      class ChainableParticle extends Particle {
        setNextSibling(sibling) {
          this.nextSibling = sibling;
        }
        setPrevSibling(sibling) {
          this.prevSibling = sibling;
        }
      }

      class DistanceJoint {
        constructor(pointA, pointB, len, strength) {
          this.pointA = pointA;
          this.pointB = pointB;
          this.len = len;
          this.strength = strength;
        }

        update(dt = 1) {
          const diffx = this.pointB.x - this.pointA.x;
          const diffy = this.pointB.y - this.pointA.y;
          const mag = Math.sqrt(diffx * diffx + diffy * diffy);
          const diffMag = this.len - mag;
          if (mag > 0) {
            const totalMass = this.pointA.mass + this.pointB.mass;
            const dA =
              (((this.pointA.mass / totalMass) * diffMag * this.strength) /
                mag) *
              -dt;
            const dB =
              (((this.pointB.mass / totalMass) * diffMag * this.strength) /
                mag) *
              dt;
            this.pointA.move(diffx * dA, diffy * dA);
            this.pointB.move(diffx * dB, diffy * dB);
          }
        }
      }

      /* --------------------------------------------------------
          Spatial hash grid
      -------------------------------------------------------- */

      class HashGrid {
        constructor(width, height, cellSize) {
          this.width = width;
          this.height = height;
          this.cellSize = cellSize;
          this.grid = new Map();
          this._scratch = [];
        }

        getIndex(value) {
          return (value / this.cellSize) | 0;
        }

        _getKeyByIndices(xi, yi) {
          return xi + "." + yi;
        }

        getKey(x, y) {
          return this._getKeyByIndices(this.getIndex(x), this.getIndex(y));
        }

        addItem(item) {
          const key = this.getKey(item.x, item.y);
          let cell = this.grid.get(key);
          if (!cell) {
            cell = new Set();
            this.grid.set(key, cell);
          }
          cell.add(item);
          return cell;
        }

        query(x, y, radius) {
          const xi0 = this.getIndex(x - radius) - 1;
          const xi1 = this.getIndex(x + radius) + 1;
          const yi0 = this.getIndex(y - radius) - 1;
          const yi1 = this.getIndex(y + radius) + 1;

          const result = this._scratch;
          result.length = 0;

          for (let xi = xi0; xi <= xi1; xi++) {
            for (let yi = yi0; yi <= yi1; yi++) {
              const key = this._getKeyByIndices(xi, yi);
              const cell = this.grid.get(key);
              if (cell) cell.forEach((item) => result.push(item));
            }
          }
          return result;
        }

        createClient(item) {
          return new HashGridClient(this, item);
        }
      }

      class HashGridClient {
        constructor(hashGrid, item) {
          this.hashGrid = hashGrid;
          this.item = item;
          this.indexX = this.hashGrid.getIndex(this.item.x);
          this.indexY = this.hashGrid.getIndex(this.item.y);
          this.cell = this.hashGrid.addItem(this.item);
        }

        update() {
          const newIndexX = this.hashGrid.getIndex(this.item.x);
          const newIndexY = this.hashGrid.getIndex(this.item.y);
          if (newIndexX === this.indexX && newIndexY === this.indexY) return;

          this.cell.delete(this.item);
          this.cell = this.hashGrid.addItem(this.item);
          this.indexX = newIndexX;
          this.indexY = newIndexY;
        }
      }

      /* --------------------------------------------------------
          Setup and Main Loop
      -------------------------------------------------------- */

      let substeps = 6;
      const vertexDistanceRel = 0.008;

      let marginX = 40;
      let marginY = 40;
      const PACK_FACTOR = 0.7;

      const GROWTH_RATE = 0.35;
      const MAX_SCALE = 3.8;
      const SQUISH_FRACTION = 0.1;

      // --- readable-first phase ---
      let buildStartMs = 0;
      const LAYOUT_MS = 2000; // longer so you can read it
      const LAYOUT_PULL = 12.0;

      let mx, my;
      let blobs = [];
      let particles = [];
      let distanceJoints = [];
      let hashGrid;
      let effectiveVertexDistance;
      let letterFont;

      const MAX_WIDTH_FOR_HOLLAND_ONLY = 480;
      let WORD_LINES;

      function smoothstep01(x) {
        x = constrain(x, 0, 1);
        return x * x * (3 - 2 * x);
      }

      // NEW: keep letters in reading order briefly (prevents scrambling)
      function applyReadingOrderConstraints(sdt) {
        const tMs = millis() - buildStartMs;
        if (tMs >= LAYOUT_MS) return;

        const u = tMs / LAYOUT_MS;
        const fade = 1 - smoothstep01(u);

        // required min center gap between adjacent letters (tweak this)
        const minGap = effectiveVertexDistance * 22;

        // group by line
        const byLine = new Map();
        for (let i = 0; i < blobs.length; i++) {
          const bl = blobs[i];
          const key = bl.lineIndex ?? 0;
          if (!byLine.has(key)) byLine.set(key, []);
          byLine.get(key).push(bl);
        }

        byLine.forEach((lineBlobs) => {
          // sort by intended order
          lineBlobs.sort((a, b) => (a.posInWord ?? 0) - (b.posInWord ?? 0));

          for (let i = 1; i < lineBlobs.length; i++) {
            const prev = lineBlobs[i - 1];
            const curr = lineBlobs[i];

            // if curr is too far left (crossing / compressed), push apart
            const desired = prev.cx + minGap;
            const err = desired - curr.cx;
            if (err > 0) {
              const push = err * 0.85 * fade * sdt;

              for (let k = 0; k < prev.allParticles.length; k++) {
                prev.allParticles[k].move(-push, 0);
              }
              for (let k = 0; k < curr.allParticles.length; k++) {
                curr.allParticles[k].move(push, 0);
              }
            }
          }
        });
      }

      function setWordLines() {
        if (windowWidth <= MAX_WIDTH_FOR_HOLLAND_ONLY) {
          WORD_LINES = ["HOLLAND"];
        } else {
          WORD_LINES = ["HOLLAND"];
        }
      }

      function preload() {
        letterFont = loadFont(
          "https://assets.codepen.io/9259849/RubikMonoOne-Regular_1.ttf",
        );
      }

      function setup() {
        createCanvas(windowWidth, windowHeight);
        colorMode(RGB, 255);
        pixelDensity(1);
        frameRate(50);
        cursor(CROSS);
        buildLetters();
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        buildLetters();
      }

      function buildLetters() {
        setWordLines();

        effectiveVertexDistance = vertexDistanceRel * min(width, height);

        const m = min(width, height);
        marginX = m * 0.08;
        marginY = m * 0.08;

        mx = width / 2;
        my = height / 2;

        hashGrid = new HashGrid(
          width,
          height,
          Math.floor(effectiveVertexDistance * 2),
        );
        particles = [];
        distanceJoints = [];
        blobs = [];

        buildStartMs = millis();

        const minLength = min(width, height);
        const radius = minLength * 0.16;
        const fontSize = radius * 2.7;
        const lineSpacing = radius * 1.6;

        let letterIndex = 0;

        for (let lineIndex = 0; lineIndex < WORD_LINES.length; lineIndex++) {
          const WORD = WORD_LINES[lineIndex];
          const letters = WORD.split("");

          // NEW: position within the word (H=0, O=1, ...)
          let posInWord = 0;

          const infos = letters.map((ch) => {
            if (ch === " ") {
              return { char: " ", width: radius * 0.8, isSpace: true };
            }
            const b = letterFont.textBounds(ch, 0, 0, fontSize);
            return { char: ch, width: b.w, isSpace: false };
          });

          const LETTER_GAP = radius * 0.25;

          let localCenters = [];
          let xCursor = 0;

          for (let i = 0; i < infos.length; i++) {
            const info = infos[i];
            if (info.isSpace) {
              xCursor += info.width;
              continue;
            }
            const cxLocal = xCursor + info.width / 2;
            localCenters.push({ index: i, cxLocal, width: info.width });
            xCursor += info.width;
            if (i < infos.length - 1) xCursor += LETTER_GAP;
          }

          const origLineWidth = xCursor;
          const targetWidth = origLineWidth * PACK_FACTOR;
          const lineStartX = (width - targetWidth) / 2;

          const totalTextHeight = lineSpacing * (WORD_LINES.length - 1);
          const firstBaseY = height * 0.5 - totalTextHeight * 0.5;
          const baseY = firstBaseY + lineIndex * lineSpacing;

          const scaleX = targetWidth / origLineWidth;

          let visibleIndex = 0;

          for (let i = 0; i < infos.length; i++) {
            const info = infos[i];
            if (info.isSpace) continue;

            const lc = localCenters[visibleIndex];
            const cx = lineStartX + lc.cxLocal * scaleX;
            const cy = baseY;

            const blob = generateLetterBlob(
              cx,
              cy,
              radius,
              info.char,
              letterIndex,
            );

            // readable-first target
            blob.targetX = cx;
            blob.targetY = cy;

            // NEW: reading order metadata
            blob.lineIndex = lineIndex;
            blob.posInWord = posInWord;
            posInWord++;

            blobs.push(blob);
            blob.allParticles.forEach((p) => particles.push(p));
            blob.allJoints.forEach((j) => distanceJoints.push(j));

            letterIndex++;
            visibleIndex++;
          }
        }
      }

      function draw() {
        const mr = min(width, height) * 0.07;
        mx = lerp(mx, mouseX, 0.25);
        my = lerp(my, mouseY, 0.25);

        const dt = 1 / 60;
        const sdt = dt / substeps;

        for (let i = particles.length; i--; ) particles[i].updateClient();

        for (let sub = 0; sub < substeps; sub++) {
          // 1) integrate
          for (let i = particles.length; i--; ) {
            const p = particles[i];
            const v = geometry.limit(
              { x: p.vx, y: p.vy },
              (effectiveVertexDistance / sdt) * 1.0,
            );
            p.vx = v.x;
            p.vy = v.y;
            p.update(sdt);
          }

          // 2) joints
          for (let i = distanceJoints.length; i--; )
            distanceJoints[i].update(1);

          // 3) growth + radius update
          for (let b = 0; b < blobs.length; b++) {
            const blob = blobs[b];
            if (blob.growing)
              blob.scale = Math.min(MAX_SCALE, blob.scale + GROWTH_RATE * sdt);
            const rScale = blob.scale;
            for (let i = 0; i < blob.allParticles.length; i++) {
              const p = blob.allParticles[i];
              p.radius = p.baseRadius * rScale;
            }
          }

          // 4) inter-letter collisions
          for (let i = particles.length; i--; ) {
            const p = particles[i];
            const neighbors = hashGrid.query(p.x, p.y, p.radius * 1.1);
            for (let n = 0; n < neighbors.length; n++) {
              const o = neighbors[n];
              if (o === p || o === p.nextSibling || o === p.prevSibling)
                continue;
              if (o.parent === p.parent) continue;

              const f = p.testCollision(o.x, o.y, o.radius);
              if (f) {
                const push = 0.5;
                p.move(f.x * push, f.y * push);
                o.move(-f.x * push, -f.y * push);
              }
            }
          }

          // 5) anchor to shape + readable pull
          const anchorK = 5;
          const MAX_STRETCH = 1.05;

          for (let b = 0; b < blobs.length; b++) {
            const blob = blobs[b];

            // center
            let cx = 0,
              cy = 0;
            for (let i = 0; i < blob.allParticles.length; i++) {
              cx += blob.allParticles[i].x;
              cy += blob.allParticles[i].y;
            }
            cx /= blob.allParticles.length;
            cy /= blob.allParticles.length;
            blob.cx = cx;
            blob.cy = cy;

            // readable-first attraction (fades out)
            const tMs = millis() - buildStartMs;
            if (tMs < LAYOUT_MS && blob.targetX !== undefined) {
              const u = tMs / LAYOUT_MS;
              const fade = 1 - smoothstep01(u);

              const dx = (blob.targetX - blob.cx) * LAYOUT_PULL * fade * sdt;
              const dy = (blob.targetY - blob.cy) * LAYOUT_PULL * fade * sdt;

              for (let k = 0; k < blob.allParticles.length; k++) {
                blob.allParticles[k].move(dx, dy);
              }
            }

            // shape anchor + clamp
            const s = blob.scale;

            let squishSum = 0;
            let squishCount = 0;

            for (let i = 0; i < blob.allParticles.length; i++) {
              const p = blob.allParticles[i];

              const targetX = cx + p.restDX * s;
              const targetY = cy + p.restDY * s;
              const aw = p.anchorWeight ?? 1.0;

              p.move(
                (targetX - p.x) * anchorK * aw * sdt,
                (targetY - p.y) * anchorK * aw * sdt,
              );

              const dxCenter = p.x - cx;
              const dyCenter = p.y - cy;
              const distFromCenter = Math.hypot(dxCenter, dyCenter);
              const restDist = Math.hypot(p.restDX * s, p.restDY * s);

              if (restDist > 0 && distFromCenter > restDist * MAX_STRETCH) {
                const ratio = (restDist * MAX_STRETCH) / distFromCenter;
                p.x = cx + dxCenter * ratio;
                p.y = cy + dyCenter * ratio;
              }

              const off = Math.hypot(p.x - targetX, p.y - targetY);
              const idealR = Math.max(
                1,
                Math.hypot(p.restDX * s, p.restDY * s),
              );
              squishSum += off / idealR;
              squishCount++;
            }

            const avgSquish = squishCount > 0 ? squishSum / squishCount : 0;
            if (blob.growing && avgSquish >= SQUISH_FRACTION)
              blob.growing = false;
          }

          // NEW: enforce left-to-right order briefly (prevents HOLLAND turning into a pile)
          applyReadingOrderConstraints(sdt);

          // 6) blob center repulsion
          for (let i = 0; i < blobs.length; i++) {
            for (let j = i + 1; j < blobs.length; j++) {
              const bi = blobs[i];
              const bj = blobs[j];

              const dx = bj.cx - bi.cx;
              const dy = bj.cy - bi.cy;
              const distSq = dx * dx + dy * dy;
              if (distSq < 1e-4) continue;

              const minDist =
                (bi.maxDist * bi.scale + bj.maxDist * bj.scale) * 0.55;
              if (distSq < minDist * minDist) {
                const dist = Math.sqrt(distSq);
                const overlap = (minDist - dist) / dist;

                const push = overlap * 0.25;
                const ox = dx * push;
                const oy = dy * push;

                for (let k = 0; k < bi.allParticles.length; k++)
                  bi.allParticles[k].move(-ox, -oy);
                for (let k = 0; k < bj.allParticles.length; k++)
                  bj.allParticles[k].move(ox, oy);
              }
            }
          }

          // 7) mouse + bounds
          for (let i = particles.length; i--; ) {
            const p = particles[i];
            p.collide(mx, my, mr);
            p.constrain(marginX, marginY, width - marginX, height - marginY);
            p.endUpdate(sdt);
          }
        }

        // draw
        background("#c5c5c5");

        push();
        noStroke();
        fill("#a5a5a5");
        circle(mx, my, mr * 2 - 2);
        pop();

        for (let i = 0; i < blobs.length; i++) drawLetter(blobs[i]);
      }

      /* --------------------------------------------------------
          Build Blob – contours
      -------------------------------------------------------- */

      function generateLetterBlob(offsetX, offsetY, radius, letter, index) {
        const fontSize = radius * 2.7;

        const bounds = letterFont.textBounds(letter, 0, 0, fontSize);
        const bx = bounds.x,
          by = bounds.y,
          bw = bounds.w,
          bh = bounds.h;

        const rawPoints = letterFont.textToPoints(letter, 0, 0, fontSize, {
          sampleFactor: 0.65,
          simplifyThreshold: 0,
        });

        const allLoops = [];
        let currentLoop = [];
        let lastRaw = null;

        const breakThreshold = effectiveVertexDistance * 8;

        for (let i = 0; i < rawPoints.length; i++) {
          const pt = rawPoints[i];

          if (lastRaw) {
            const rawD = dist(lastRaw.x, lastRaw.y, pt.x, pt.y);
            if (rawD > breakThreshold && currentLoop.length > 0) {
              allLoops.push(currentLoop);
              currentLoop = [];
            }
          }
          lastRaw = { x: pt.x, y: pt.y };

          const px = pt.x - bx - bw * 0.5 + offsetX;
          const py = pt.y - by - bh * 0.5 + offsetY;

          const PARTICLE_COLLISION_RADIUS = effectiveVertexDistance * 0.8;

          if (currentLoop.length === 0) {
            currentLoop.push(
              new ChainableParticle({
                x: px,
                y: py,
                damping: 1,
                friction: 0.1,
                radius: PARTICLE_COLLISION_RADIUS,
                mass: 1,
              }),
            );
          } else {
            const last = currentLoop[currentLoop.length - 1];
            const d = dist(last.x, last.y, px, py);
            if (d >= effectiveVertexDistance * 1.0) {
              currentLoop.push(
                new ChainableParticle({
                  x: px,
                  y: py,
                  damping: 1,
                  friction: 0.1,
                  radius: PARTICLE_COLLISION_RADIUS,
                  mass: 1,
                }),
              );
            }
          }
        }
        if (currentLoop.length > 0) allLoops.push(currentLoop);

        const letterParticles = [];
        const letterJoints = [];
        const processedLoops = [];

        for (let li = 0; li < allLoops.length; li++) {
          const loop = allLoops[li];
          if (loop.length < 3) continue;

          loop.forEach((v, i, arr) => {
            v.setPrevSibling(arr[(i - 1 + arr.length) % arr.length]);
            v.setNextSibling(arr[(i + 1) % arr.length]);
            v.setClient(hashGrid.createClient(v));

            v.radius = effectiveVertexDistance * 1.8;
            v.baseRadius = v.radius;

            letterParticles.push(v);
          });

          const currentLoopJoints = loop
            .map((v) => {
              const v2 = v.nextSibling.nextSibling || v.nextSibling;

              const d1 = dist(v.x, v.y, v.nextSibling.x, v.nextSibling.y);
              const joint1 = new DistanceJoint(
                v,
                v.nextSibling,
                d1 * 1.02,
                0.75,
              );

              const d2 = dist(v.x, v.y, v2.x, v2.y);
              const joint2 = new DistanceJoint(v, v2, d2 * 1.02, 0.3);

              return [joint1, joint2];
            })
            .flat();

          letterJoints.push(...currentLoopJoints);
          processedLoops.push(loop);
        }

        const baseArea = processedLoops.reduce(
          (sum, currentLoop) =>
            sum + Math.abs(geometry.polygonArea(currentLoop)),
          0,
        );
        const area = baseArea * random(1.02, 1.08);

        const palette = [
          [22, 100, 91],
          [40, 100, 82],
          [48, 35, 98],
          [58, 52, 42],
          [50, 64, 100],
          [320, 60, 70],
        ];
        const col = palette[index % palette.length];

        const blob = {
          area,
          currentArea: area,
          allParticles: letterParticles,
          allJoints: letterJoints,
          radius,
          color: color(col[0], col[1], col[2]),
          cx: 0,
          cy: 0,
          restCX: 0,
          restCY: 0,
          maxDist: 0,
          scale: 1,
          growing: true,
          loops: processedLoops,

          // readable-first targets / metadata (filled in buildLetters)
          targetX: undefined,
          targetY: undefined,
          lineIndex: 0,
          posInWord: 0,
        };

        // center + rest offsets
        let cx = 0,
          cy = 0;
        letterParticles.forEach((p) => {
          cx += p.x;
          cy += p.y;
          p.parent = blob;
        });
        cx /= letterParticles.length;
        cy /= letterParticles.length;
        blob.restCX = cx;
        blob.restCY = cy;

        let maxDist = 0;
        letterParticles.forEach((p) => {
          p.restDX = p.x - cx;
          p.restDY = p.y - cy;
          maxDist = Math.max(maxDist, Math.hypot(p.restDX, p.restDY));
        });
        blob.maxDist = maxDist;

        letterParticles.forEach((p) => {
          const d = maxDist > 0 ? Math.hypot(p.restDX, p.restDY) / maxDist : 1;
          const t = constrain(d, 0, 1);
          p.squishWeight = constrain(map(t, 0, 1, 0.7, 1.4), 0.7, 1.4);
          p.anchorWeight = constrain(map(t, 0, 1, 1.6, 0.45), 0.45, 1.6);
        });

        return blob;
      }

      /* --------------------------------------------------------
          Rendering – cream fill with counters + strokes
      -------------------------------------------------------- */

      function drawLetter(blob) {
        if (!blob.loops || blob.loops.length === 0) return;

        const contours = [];

        for (let li = 0; li < blob.loops.length; li++) {
          const contour = blob.loops[li];
          if (contour.length < 3) continue;

          const len = contour.length;
          let smooth = new Array(len);

          for (let i = 0; i < len; i++)
            smooth[i] = { x: contour[i].x, y: contour[i].y };

          for (let k = 0; k < 4; k++) {
            const tmp = new Array(len);
            for (let i = 0; i < len; i++) {
              const prev = smooth[(i - 1 + len) % len];
              const curr = smooth[i];
              const next = smooth[(i + 1) % len];
              tmp[i] = {
                x: (prev.x + curr.x * 2 + next.x) / 4,
                y: (prev.y + curr.y * 2 + next.y) / 4,
              };
            }
            smooth = tmp;
          }

          const curvePts = [];
          curvePts.push(smooth[len - 2], smooth[len - 1]);
          for (let i = 0; i < len; i++) curvePts.push(smooth[i]);
          curvePts.push(smooth[0], smooth[1]);
          contours.push(curvePts);
        }

        if (contours.length === 0) return;

        const ctx = drawingContext;
        ctx.save();
        ctx.fillStyle = "#F7E9A9";
        ctx.beginPath();

        contours.forEach((curvePts) => {
          ctx.moveTo(curvePts[0].x, curvePts[0].y);
          for (let i = 1; i < curvePts.length; i++)
            ctx.lineTo(curvePts[i].x, curvePts[i].y);
          ctx.closePath();
        });

        ctx.fill("evenodd");
        ctx.restore();

        const drawStroke = (curvePts, sw) => {
          stroke(247, 233, 169);
          strokeWeight(sw);
          strokeJoin(ROUND);
          strokeCap(ROUND);
          noFill();
          beginShape();
          for (let i = 0; i < curvePts.length; i++)
            curveVertex(curvePts[i].x, curvePts[i].y);
          endShape();
        };

        push();
        contours.forEach((curvePts) => {
          drawStroke(curvePts, 16);
          drawStroke(curvePts, 5);
        });
        pop();
      }
    </script>
  </body>
</html>
